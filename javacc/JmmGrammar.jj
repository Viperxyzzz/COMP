PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< CLASS : "class" > |
	< INT_ARR : "int[]" > |
	< INT : "int" > |
	< INTEGER : (["0" - "9"])+ > |
    < IDENTIFIER: (["a" - "z"])+ >
;


Start : ImportDeclaration ClassDeclaration <EOF>;

AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< TIMES > | < DIVIDE >)
		Factor
	)?
;

Factor :
	< INTEGER > |
	< MINUS> Factor |
	< OPEN_PAREN > AdditiveExpression < CLOSE_PAREN >
;


ImportDeclaration:
    (
        "import" < IDENTIFIER > ( "." < IDENTIFIER > )* ";"
    )*
;

ClassDeclaration:
    < CLASS > < IDENTIFIER >
    (
        "extends" < IDENTIFIER >
    )?
    "{" ( VarDeclaration )* ( MethodDeclaration )*
    "}"
;

VarDeclaration:
    Type < IDENTIFIER > ";"
;

MethodDeclaration:
    "public" Type < IDENTIFIER > "("
    (Type < IDENTIFIER > ( "," Type < IDENTIFIER > )* )?
    ")"
    "{" ( VarDeclaration )* ( Statement )* "return" Expression ";" "}" |
    "public" "static" "void" "main" "(" "String" "[" "]" < IDENTIFIER > ")" "{" ( VarDeclaration )* ( Statement )* "}"
;

Type:
    <INT_ARR> |
    "boolean" |
    "int" |
    < IDENTIFIER >
;

Statement:
    "{" ( Statement )* "}" |
    "if" "(" Expression ")" Statement "else" Statement |
    "while" "(" Expression ")" Statement |
    Expression ";" |
    < IDENTIFIER > "=" Expression ";" |
    < IDENTIFIER > "[" Expression "]" "=" Expression ";"
;

Expression:
    "true" |
    "false" |
    < IDENTIFIER > |
    "this" |
    "new" "int" "[" Expression "]" |
    "new" < IDENTIFIER > "(" ")" |
    "!" Expression |
    "(" Expression ")"
;
