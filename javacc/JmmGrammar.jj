PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES = false;

SKIP : " " | "\t" | "\r" | "\n" | <"//" (~["\n"])*>;

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< IMPORT : "import" > |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< RETURN : "return" > |
	< PUBLIC : "public" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< LENGTH : "length" > |
	< EQUAL : "=" > |
	< EQUALEQUAL : "==" > |
	< STRING : "String" > |
	< BOOLEAN : "boolean" > |
	< INT_ARR : "int[]" > |
	< INT : "int" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< THIS : "this" > |
	< NEW : "new" > |
	< LSQUARE : "[" > |
	< RSQUARE : "]" > |
	< SEMICOLON : ";" > |
	< LESSTHAN : "<" > |
	< BIGGERTHAN : ">" > |
	< AND : "&&" > |
	< OR : "||" > |
    < INTEGER : (["0" - "9"])+ > |
    < IDENTIFIER: ((["a" - "z"] | ["A" - "Z"] | "$" | "_") (["a" - "z"] | ["A" - "Z"] | "$" | "_" | ["0" - "9"])*) >
;


Start : ImportDeclaration ClassDeclaration <EOF>;

Assignment:
    LogicalExpression
    (
        < EQUAL >
        Assignment
    )?
;

LogicalExpression:
    ComparableExpression
    (
        (< AND > | < OR >)
        Assignment
    )?
;

ComparableExpression:
    AdditiveExpression
    (
        (< LESSTHAN > | < BIGGERTHAN > | < EQUALEQUAL >)
        Assignment
    )?
;

AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		Assignment
	)?
;

MultiplicativeExpression :
	ParenExpression
	(
		(< TIMES > | < DIVIDE >)
		Assignment
	)?
;

ParenExpression :
    ArrayExpression
	(
	    < OPEN_PAREN > Assignment < CLOSE_PAREN >
    )?
;

ArrayExpression:
    DotExpression
    (
        < LSQUARE > Assignment <RSQUARE>
    )?
;

DotExpression:
     Factor
     (
        "." ( < LENGTH > | < IDENTIFIER > "(" ( Assignment ( "," Assignment )* )? ")" )
     )*
 ;

Factor :
	< INTEGER > |
	< MINUS> Factor |
	ExpressionFirst
;


ImportDeclaration:
    (
        < IMPORT > < IDENTIFIER > ( "." < IDENTIFIER > )* < SEMICOLON >
    )*
;

ClassDeclaration:
    < CLASS > < IDENTIFIER >
    (
        < EXTENDS > < IDENTIFIER >
    )?
    "{" ( VarDecl )* ( MethodDeclaration )*
    "}"
;

VarDecl:
    SCAN 2 Type < IDENTIFIER > < SEMICOLON >
;

MethodDeclaration:
    < PUBLIC > (Pti | Psvm)
;

Pti:
    Type < IDENTIFIER > < OPEN_PAREN > (Type < IDENTIFIER > ( "," Type < IDENTIFIER > )* )? < CLOSE_PAREN > "{"
    ( VarDecl )* ( Statement )* < RETURN > Assignment < SEMICOLON >
    "}"
;

Psvm:
    < STATIC > < VOID > < MAIN > < OPEN_PAREN > < STRING > "[" "]" < IDENTIFIER > < CLOSE_PAREN > "{"
    ( VarDecl )* ( Statement )*
    "}"
;

Type:
    < INT_ARR > |
    < BOOLEAN > |
    < INT > |
    < IDENTIFIER >
;

Statement:
    "{" ( Statement )* "}" |
    < IF > < OPEN_PAREN > Assignment < CLOSE_PAREN > Statement < ELSE > Statement |
    < WHILE > < OPEN_PAREN > Assignment < CLOSE_PAREN > Statement |
    Assignment < SEMICOLON >
;

Expression:
    ExpressionFirst (
        ("&&" | < PLUS > | < MINUS > | < TIMES > | < DIVIDE > | < LESSTHAN > | < EQUAL >) Expression |
        "." ( < LENGTH > | < IDENTIFIER > "(" ( Expression ( "," Expression )* )? ")" ) |
        < LSQUARE > Expression <RSQUARE>
    )*
;

ExpressionFirst:
    < INTEGER > |
    < TRUE > |
    < FALSE > |
    < IDENTIFIER > |
    < THIS > |
    < NEW > (< INT > < LSQUARE > Assignment < RSQUARE > | < IDENTIFIER > < OPEN_PAREN > < CLOSE_PAREN >) |
    "!" Expression |
    < OPEN_PAREN > Assignment < CLOSE_PAREN > |
    < LSQUARE > Assignment < RSQUARE >
;

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}
